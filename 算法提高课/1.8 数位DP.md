## 数位 DP

y 总的数位 DP 中的 DP 是指预处理

### 技巧

1. 把两个界限的区间问题 `[X,Y]` 变成一个界限的区间问题 `[0,Y]-[0,X-1]`
2. 不是暴力枚举数，而是**枚举数位**
3. 以 “树” 的方式思考问题，也是一种分类讨论的思想，假设对于数：`N`，要枚举 `n` 位 `a[n-1] a[n-2] ... a[0]` 的选择，每一位只有两种情况：
    - 左侧分支：填 `0~a[i]-1`，那么后面的数可以随便填，不受影响。一般左侧分支可以直接预处理（大概率也是动态规划）求出来，因为不受限制。
    - 右侧分支：
        - 填 `a[i]`，后面的数会有限制，又要分情况讨论 `a[i+1]`，重复上述两种情况
        - 特殊情况：最后一个右侧分支，此时数已经全部定死，需特判

### [1081. 度的数量](https://www.acwing.com/problem/content/1083/)

求给定区间 `[X,Y]` 中满足下列条件的整数个数：这个数恰好等于 `K` 个互不相等的 `B` 的整数次幂之和。

#### 题目分析

`B` 的整数次幂之和：把一个 `n` 转成 `B` 进制后得到 `n'`，如果这个 `n'` 中的每一位都是 `1` 就说明 `n` 等于 `B` 的整数次幂之和

对应到这个题目，先把 `[X,Y]` 中的数表示成 `B` 进制，那么答案就是**满足只包含 `K` 个 1，其余位为 0 的数** 的个数

另外，`[X,Y]` 的范围在 `2^31`，如果暴力枚举这些数，肯定会超时，所以要枚举数位。

本题的分情况讨论，每一位只能填 `0` 或者 `1`，当要填最高位 `n-1` 位时：

- 左侧分支：要求填的数不能够使后面的数受限制，又因为只能填 `0 1`，所以要根据 `a[n-1]` 的值分情况讨论：
    
    - `a[n-1] > 1`，`0 1` 都可以填，不影响后面。则答案就是：1. 填 0，要从剩下的 `n-1` 位中填 `K` 个 `1`，方案数就是 `C[n-1][K]`；2. 填 `1`，则要从剩下的 `n-1` 位中填 `K - 1` 个 `1`，方案数就是 `C[n-1][K-1]`，这样这个分支的答案就是两者相加。又因为 `a[n-1] > 1`，**此时没有右侧分支**，因为选 `a[n-1] != 1` 的情况不合法

    - `a[n-1] == 1`，只能填 `0` 才不会影响后面。填 0，要从剩下的 `n-1` 位中填 `K` 个 `1`，方案数就是 `C[n-1][K]`。同时注意，选 `1` 的就是计算右侧分支的方案数，且剩余 `1` 的个数减 1

    - `a[n-1] == 0`，此时左侧分支啥也选不了。乖乖去计算右侧分支，且剩余 `1` 的个数不变

- 右侧分支：
    
    - 填 `a[n-1]` 了之后，讨论 `a[n-2]` 如何计算，重复上述分情况讨论的过程

    - 当进入最后一位的右侧分支时，说明所有的位都已经被选好了，只需要看一下是否选了 K 个 `1`，如果是的话，答案需再加 1

代码
```C++
int dp(int n) {
    if (!n) return 0;
    // 得到 n 的 B 进制
    vector<int> nums;
    while (n) nums.push_back(n % B), n /= B;
    // 答案个数
    int res = 0;
    // 前缀信息
    int last = 0;  // 本题表示前面选的这些数中已经有多少个 1 了
    // 从高位到低位枚举
    for (int i = nums.size() - 1; i >= 0; i--) {
        int x = nums[i];
        // 先考虑左侧分支
        if (x > 1) {
            // 选 0
            res += f[i][K - last];
            // 选 1
            if (K - last - 1 >= 0) 
                res += f[i][K-last-1];
            break;
        } else if (x == 1) {
            if (K - last >= 0)
                res += f[i][K - last];
            last++;
            if (last > K) 
                break;
        }
        // 下次循环计算右侧分支的情况
        // 右侧分支的最后一个
        if (!i && last == K) res++; 
    }
    return res;
}
```

### [1082. 数字游戏](https://www.acwing.com/problem/content/1084/)

科协里最近很流行数字游戏。某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123，446。现在大家决定玩一个游戏，指定一个整数闭区间 `[a,b]`，问这个区间内有多少个不降数。

#### 预处理不受限制的不降数的个数

状态表示：

- 集合：`f[i][j]` 表示所有最高位是 j，且一共有 i 位的不降数的集合

- 属性：数量

状态计算：

显然，`f[i][j]` 表示一个 `i` 位的数，它可以由一个 `i-1` 位的数在前面加上数 `j` 得到，那么为了保证**不降**的性质，第 `i-1` 位的数必须大于 `j`。那么就得到了计算公式：`f[i][j] = f[i-1][j+1] + f[i-1][j+2] + ... +f[i-1][9]`

边界：`f[1][j] = 1`，因为个位数都是递增的，且只有这一个数 `j`

整体代码
```C++
// f[i][j] 表示一共 i 位，且最高位为 j 的不降数的个数
int f[N][N];

void init() {
    for (int i = 0; i <= 9; i++) f[1][i] = 1;
    for (int i = 2; i < N; i++) {
        for (int j = 0; j <= 9; j++) {
            for (int k = j; k <= 9; k++) {
                f[i][j] += f[i-1][k];
            }
        }
    }
}

int dp(int n) {
    // 0 要特判
    if (!n) return 1;
    // 其他数拆到 nums 中
    vector<int> nums;
    while (n) nums.push_back(n % 10), n /= 10;

    int res = 0; // 方案数
    // 前缀信息：选定的这些数是否是不降的，只需要存上一个数就行
    int last = 0; // 确保每次从 last 开始取数 

    for (int i = nums.size() - 1; i >= 0; i--) {
        // 左侧分支
        int x = nums[i];
        for (int j = last; j < x; j++) {
            res += f[i+1][j];
        }
        // 当前这位能不能填 x 不能就结束
        if (last > x) break;
        last = x;
        // 当安全的到达 最后的右侧分支
        if (!i) res++; 
    }
    return res;
}
```

### [1083. Windy数](https://www.acwing.com/problem/content/1085/)

Windy 定义了一种 Windy 数：不含前导零且相邻两个数字之差至少为 2 的正整数被称为 Windy 数。

Windy 想知道，在 A 和 B 之间，包括 A 和 B，总共有多少个 Windy 数？

#### 前导零带来的问题

当遇到前导零的问题时，可以特判处理：按照含前导零和不含前导零分开计算

整体代码
```C++
// f[i][j] 表示总共 i 位，且最高位是 j 的 Windy 数的个数
// f[i][j] 是包含前导零的情况的，而含前导零的情况会漏数
// 比如：0157 这个数其实是 157，是一个 Windy 数，但是由于前导零的存在 这个数没有算进 f[4][0] 中
// 对于这些含前导 0 的数，需要找到真的最高位，比如 0157 中的 1，然后特判计算 f[3][1]（包含 157），这样就可以把这个数算进去了
// 主要原因：前导 0 没有意义，不能作为是否是 Windy 数的条件，但是 f[i][j] 中的 0 是有意义的，作为了是否是 Windy 数的条件
int f[N][10];

void init() {
    // f[i][j] += f[i-1][k]  k j 之间至少差 2
    // f[1][j] = 1
    for (int i = 0; i <= 9; i++) f[1][i] = 1;
    for (int i = 2; i < N; i ++)
        for (int j = 0; j <= 9; j++)
            for (int k = 0; k <= 9; k++)
                if (abs(j - k) >= 2)
                    f[i][j] += f[i-1][k];
}
int dp(int n) {
    // 0 不在区间内 但是题目要求不含前导零 0 就是不合法的数字 故返回 0
    if (!n) return 0; 
    vector<int> nums;
    while (n) nums.push_back(n % 10), n /= 10;

    int res = 0;
    int last = -2;  // 还是上一个数，-2 保证最高位可以任意填

    // 不含前导零的数
    for (int i = nums.size() - 1; i >= 0; i--) {
        int x = nums[i];
        // 左侧分支
        // 注意 i = n-1 时只能从 1 开始
        // i < n-1 时可以从 0 开始 此时的 0 是有意义的
        for (int j = (i == nums.size() - 1); j < x; j++)
                if (abs(j - last) >= 2)
                    res += f[i+1][j];

        // 判断能否继续进行右侧分支
        if (abs(x - last) < 2) break;
        last = x;
        if (!i) res++;
    }
    
    // 含前导零的数
    // 0xx...x 一共 1~n-1 位，最高位不取 0
    for (int i = 1; i < nums.size(); i++)
        for (int j = 1; j <= 9; j++)
            res += f[i][j];

    return res;
}
```

### [1084. 数字游戏 II](https://www.acwing.com/problem/content/1086/)

由于科协里最近真的很流行数字游戏。

某人又命名了一种取模数，这种数字必须满足各位数字之和 `mod N` 为 `0`。

现在大家又要玩游戏了，指定一个整数闭区间 `[a,b]`，问这个区间内有多少个取模数。

#### 预处理

需要预处理出来 `f[i][j][k]`：共 i 位，最高位是 j，且模 N 为 k 的数的个数

状态计算：

考虑 `f[i][j][k]` 由一个共 `i-1` 位的状态转移过来，假设它的最高位是 `x`，那么它模 `N` 的值应为：`(k-j) % N`，这样转移到 `f[i][j]` 时，模 `N` 的值才是 `k`。

所以 `f[i][j][k]` 由 `f[i-1][x][(k-j) % N]` 转移而来

```C++
int P;
int f[N][10][M];

int mod(int x, int y) { return (x % y + y) % y; }

void init() {
    memset(f, 0, sizeof f);
    // 边界
    for (int i = 0; i <= 9; i++)
        f[1][i][i % P] = 1;
    // 状态转移
    for (int i = 2; i < N; i++)
        for (int j = 0; j <= 9; j++) 
            for (int k = 0; k < P; k++) 
                for (int x = 0; x <= 9; x++) 
                    f[i][j][k] += f[i - 1][x][mod(k - j, P)];
}

int dp(int n) {
    // 0 符合条件
    if (!n)
        return 1;
    vector<int> nums;
    while (n)
        nums.push_back(n % 10), n /= 10;

    int res = 0;
    int last = 0; // 存前面数的和
    for (int i = nums.size() - 1; i >= 0; i--) {
        int x = nums[i];
        // 不选这一位的数
        for (int j = 0; j < x; j++) {
            res += f[i+1][j][mod(-last, P)];
        }
        // 选这个数 就加上它 然后进行下一个循环
        last += x;
        // 最后的右分支 数都选好了
        if (!i && last % P == 0) res++; 
    }
    return res;
}
```

### [1085. 不要62](https://www.acwing.com/problem/content/1087/)

杭州人称那些傻乎乎粘嗒嗒的人为 62（音：laoer）。

杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。

不吉利的数字为所有含有 4 或 62 的号码。例如：62315,73418,88914 都属于不吉利号码。但是，61152 虽然含有 6 和 2，但不是 连号，所以不属于不吉利数字之列。

你的任务是，对于每次给出的一个牌照号区间 [n,m]，推断出交管局今后又要实际上给多少辆新的士车上牌照了。

```C++
void init() {
    // 状态转移
    // f[i][j] = f[i-1][k: 0~1 && 3 && 5~9] + f[i-1][2] if (j != 6)
    for (int i = 0; i <= 9; i++) {
        f[1][i] = 1;
        if (i == 4) f[1][i] = 0;
    }
    for (int i = 2; i < N; i++)
        for (int j = 0; j <= 9; j++) {
            if (j == 4) continue;
            for (int k = 0; k <= 9; k++) {
                if (k == 4 || j == 6 && k == 2) continue;
                f[i][j] += f[i-1][k];
            }
        }
}

int dp(int n) {
    if (!n) return 1;
    vector<int> nums;
    while (n) nums.push_back(n % 10), n /= 10;

    int res = 0;
    int last = 0;  // 前面的数字
    
    for (int i = nums.size() - 1; i >= 0; i--) {
        int x = nums[i];
        for (int j = 0; j < x; j++) {
            if (j == 4) continue;
            if (last == 6 && j == 2) continue;
            res += f[i+1][j];
        }
        // 当选这个数时，要保证不是 4 且 62 不连
        if (x == 4 || last == 6 && x == 2) break;
        last = x;
        if (!i) res++;
    }
    return res;
}
```

### [1086. 恨7不成妻](https://www.acwing.com/problem/content/1088/)

如果一个整数符合下面三个条件之一，那么我们就说这个整数和 7 有关：

1. 整数中某一位是 7；
2. 整数的每一位加起来的和是 7 的整数倍；
3. 这个整数是 7 的整数倍。

现在问题来了：吉哥想知道在一定区间内和 7 无关的整数的平方和。

这个题太难了，建议去看视频复习😣












