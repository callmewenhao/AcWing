# 最长上升子序列模型

状态表示 `f[i]`：
- 集合：所有以 `a[i]` 结尾的严格单调上升子序列
- 属性：**最大值**/最小值/数量
- `f[i]` 表示以 `a[i]` 结尾的严格单调上升子序列长度的最大值

状态计算：
- `f[i] = max({f[j], j < i && a[j] < a[i]}) + 1`
- 解释：根据上一个数 f[j] 的选择进行划分集合，最大值就是 `max(f[j]) + 1`，并且 `j` 的取值应该满足 `j < i && a[j] < a[i]`

[1017. 怪盗基德的滑翔翼](https://www.acwing.com/problem/content/1019/)

双向最长上升子序列的最大值，或者理解成（正序的）最长上升子序列与最长下降子序列的最大值

[1014. 登山](https://www.acwing.com/problem/content/1016/)

条件：
- 按照编号递增的顺序来浏览 => 必须是子序列
- 相邻两个景点海拔不能相同
- 一旦开始下降，就不能上升了

目标：最多能浏览多少景点

分析：
- 由条件 2 3 可知，整个 acm 队伍游玩的路线是先上山，再下山。
- 假设整个过程中最高的景点是景点 i，那么能游玩的最大的景点数是：i 前面能游玩的最大景点数 + i 后面能游玩的最大景点数 - 1，这两部分可以通过最长上升子序列模型提前预处理出来
- 答案就是枚举所有的 i，找一个最大值

[482. 合唱队形](https://www.acwing.com/problem/content/484/)

登山问题的对偶问题

[1012. 友好城市](https://www.acwing.com/problem/content/1014/)

这个题目有意思 🥳

条件：
- 每个城市只能建立一座桥
- 合法的方案中，所有桥与桥之间不能相交

目标：最多可以建多少桥

分析：
- 先按照下面的城市顺序对桥进行排序，就会得到上面城市的一个顺序
- 一个合法的建桥方案中，上面的城市序号应该是单调递增的，否则桥就会有交叉。其实，合法的方案唯一对应一个单调上升子序列
- 答案就是上面城市序列中最大的单调递增子序列长度

[1016. 最大上升子序列和](https://www.acwing.com/problem/content/1018/)

整体上，和最大上升子序列思路相同，只是 dp 数组的含义是最大的子序列的和

状态表示 `f[i]`：
- 集合：所有以 `a[i]` 结尾的上升子序列
- 属性：和的最大值

状态计算：
- `f[i] = max({f[j], j < i && a[j] < a[i]}) + a[i]`

[1010. 拦截导弹](https://www.acwing.com/problem/content/1012/)

- 第一问：最长上升子序列模型
- 第二问：贪心模型，类似于区间分组的思路。
    - 从前向后枚举每个导弹高度
    - 如果现有的子序列结尾的数都小于当前的导弹高度，则创建新子序列
    - 否则，将当前数放到大于等于它的最小的子序列后面
- y 总证明了贪心为什么正确，调整法 => A<= B && B <= A 
- 实际上维护了一个组单调上升的子序列，这其实就是单调上升子序列 2 的解法
- 所以，得出一个性质：**最长上升子序列的长度 == 最少用多少个最长不上升子序列覆盖整个数组**，这是一对对偶问题，详见 [dilworth 反链定理](https://www.luogu.com.cn/blog/Rolling-Code/dilworth)
- 输入没讲导弹个数，可以使用 `stringstream` 接收

[187. 导弹防御系统](https://www.acwing.com/problem/content/189/)

题意：使用最小的数目的上升子序列和下降子序列覆盖给定的数组

- 暴力枚举每个数的选择：加入最长上升子序列组，还是最长不上升子序列组（子序列 2 中维护的数组）
- 由 **dilworth 反链定理**，前者表示下降覆盖的子序列个数，后者对应上升覆盖子序列个数
- 当枚举结束后，使用两者数目的和更新答案

[272. 最长公共上升子序列](https://www.acwing.com/problem/content/274/)

状态表示 `f[i][j]`：
- 集合：所有由第一个序列的前 i 个字母，第二个序列的前 j 个字母构成的，且以 b[j] 结尾的公共上升子序列
- 属性：最大值

状态计算：
- 首先根据第一个序列结尾的字母划分状态：
    1. 所有包含 `a[i]` 的公共上升子序列，仍然用 `f[i][j]` 表示，需细分。注意，此时 `a[i] == b[j]`
    2. 所有不包含 `a[i]` 的公共上升子序列，不必细分，直接转移到状态 `f[i-1][j]`
- 对于情况 1，按照 `b[j]` 前面选取的数字进行划分：前一个是 `b[k]`，转移到 `f[i-1][k] + 1`，其中，`k < j && b[k] < b[j]`
- `f[i][j]` 是上述两种情况下的最大值 
- 本题目是公共子序列和最长上升子序列的完美结合，状态转移的两种情况分别是两种模型
- 建议看下 y 总画的集合划分示意图，以及 [题解](https://www.acwing.com/solution/content/4955/)




