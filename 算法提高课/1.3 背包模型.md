# 背包模型

## notes
基本模型 01、完全、多重（朴素+二进制优化）、分组背包 见基础课笔记

[423. 采药](https://www.acwing.com/problem/content/description/425/)

没啥好说的，非常裸的 01 背包问题

[1024. 装箱问题](https://www.acwing.com/problem/content/description/1026/)

也是一个比较裸的 01 背包问题，但是物品没有价值，根据题意物品价值==物品体积

## 多重背包（优先队列优化）

[6. 多重背包问题 III](https://www.acwing.com/problem/content/6/)

数据范围：
- N: 1000
- V: 20000
- vi, wi, si: 20000

如果使用二进制优化，时间复杂度将会是：
- 时间 = 物品个数 * 背包体积 = 1000 * log(20000) * 20000 = 2e7 * (log(20) + log(1000)) = 2e7 * 14 = 2e8

这个时间复杂度刚好会被卡住

这个时候就需要 **优先队列优化** 的多重背包了

### 优先队列优化

二进制优化，使用的是 01 背包的思想；单调队列优化，使用的是 **完全背包** 的思想

本质是：利用单调队列找区间最大值的性质，处理选择多少件（0, 1, ..., s）第 i 件物品，使得选择第 i 件物品时总价值最大？

整体思路：
- 枚举物品 i。时间 n
- 枚举余数 j，就是把尽可能多的物品 i 装入背包，剩余的背包体积，可以理解成队列的起点。时间 v
- 滑动窗口，窗口大小 s+1，以 j 为起点，直到背包体积 m。时间 m/v
- 这样总时间就是 n * m = 2e7 可以接受 

代码示例

```C++
const int N = 20010;
int n, m;
// f[N] dp 数组 g[N] 滚动数组优化 [N] 单调队列
int f[N], g[N], q[N];

int main() {
    cin >> n >> m;
    // 枚举物品
    for (int i = 0; i < n; i++) { // 时间 n
        int v, w, s;
        cin >> v >> w >> s;
        memcpy(g, f, sizeof f);
        // 枚举余数 也就是背包最终剩余体积
        for (int j = 0; j < v; j++) {  // 时间 v
            // 队列信息
            // 队列中存的是余数
            int hh = 0, tt = -1; 
            // 从余数开始滑动窗口
            // 窗口大小为 s + 1：不选 0 个 + 选 1~s 个
            for (int k = j; k <= m; k += v) { // 时间 m/v 所以总的时间就是 n * v * m / v = n * m
                // 处理队头
                if (hh <= tt && q[hh] < k - s * v) hh++;
                // 处理队尾
                // while (hh <= tt && g[q[tt]] + w * (k - q[tt]) / v <= g[k]) {
                //     tt--;
                // }
                // y 总写法 统一减掉当前下标到 j 的个数对应的价值
                // 其实两种写法本质一样，只不过我们的写法是在算真值
                // 而 y 总算了一个相对值
                while (hh <= tt && g[q[tt]] - w * (q[tt] - j) / v <= g[k] - w * (k - j) / v) {
                    tt--;
                }
                q[++tt] = k; // 把当前体积加进去
                // 根据队头计算答案：前 i-1 个物品的最大值 + 选的物品 i 的价值
                f[k] = g[q[hh]] + (k - q[hh]) / v * w;
            }
        }
    }
    
    cout << f[m] << endl; // 答案
    return 0;
}
```

## 二维费用背包

二维费用可以与 01 背包、完全背包、多重背包结合

状态表示 `f[i][j][k]`：
- 集合：所有只从前 i 个物品中选，并且总体积不超过 j，总重量不超过 k 的选法
- 属性：最大值、最小值、方案数

状态计算：根据是否选第 i 个物品进行划分
- 所有不包含物品 i 的选法。不包含物品 i 就意味着从前 i-1 个物品中选，也就是 `f[i-1][j][k]`
- 所有包含物品 i 的选法。就是 `f[i-1][j-vi][k-mi] + wi`

[8. 二维费用的背包问题](https://www.acwing.com/problem/content/8/)

二维费用 **01 背包** 问题，板子题目

代码示例

```C++
const int N = 1010, V = 110, M = 110;
int n, v, m, f[V][M];
int main() {
    cin >> n >> v >> m;
    for (int i = 0; i < n; i++) {
        int vi, mi, wi;
        cin >> vi >> mi >> wi;
        for (int j = v; j >= vi; j--) {
            for (int k = m; k >= mi; k--) {
                f[j][k] = max(f[j][k], f[j-vi][k-mi] + wi);
            }
        }
    }
    cout << f[v][m];
    return 0;
}
```

[1022. 宠物小精灵之收服](https://www.acwing.com/problem/content/description/1024/)

也是二维费用 **01 背包** 问题

[278. 数字组合](https://www.acwing.com/problem/content/280/)

题目解析：**01 背包**
- m 看成是背包容量
- 把每个数看成是一个物品，数的大小是物品体积
- 目标是求出总体积恰好等于 m 的方案数

状态表示 `f[i][j]`：
- 集合：所有只从前 i 个物品中选，且总体积恰好等于 j 的方案集合
- 属性：方案数，初始化要注意：`f[0]=1 && f[i>=1] = 0`

状态计算：
- 不选第 i 个物品的方案数：`f[i-1][j]`
- 选第 i 个物品的方案数：`f[i-1][j-vi]`
- 总方案数：`f[i][j] = f[i-1][j] + f[i-1][j-vi]`

[1019. 庆功会](https://www.acwing.com/problem/content/1021/)

价格不等于价值的 **多重背包**，简单题

[1023. 买书](https://www.acwing.com/problem/content/1025/)

**完全背包** 求方案数

[]()

[]()

[]()












