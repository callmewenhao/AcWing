# 背包模型

## notes
基本模型 01、完全、多重（朴素+二进制优化）、分组背包 见基础课笔记

[423. 采药](https://www.acwing.com/problem/content/description/425/)

没啥好说的，非常裸的 01 背包问题

[1024. 装箱问题](https://www.acwing.com/problem/content/description/1026/)

也是一个比较裸的 01 背包问题，但是物品没有价值，根据题意物品价值==物品体积

## 多重背包（优先队列优化）

[6. 多重背包问题 III](https://www.acwing.com/problem/content/6/)

数据范围：
- N: 1000
- V: 20000
- vi, wi, si: 20000

如果使用二进制优化，时间复杂度将会是：
- 时间 = 物品个数 * 背包体积 = 1000 * log(20000) * 20000 = 2e7 * (log(20) + log(1000)) = 2e7 * 14 = 2e8

这个时间复杂度刚好会被卡住

这个时候就需要 **优先队列优化** 的多重背包了

### 优先队列优化

二进制优化，使用的是 01 背包的思想；单调队列优化，使用的是 **完全背包** 的思想

本质是：利用单调队列找区间最大值的性质，处理选择多少件（0, 1, ..., s）第 i 件物品，使得选择第 i 件物品时总价值最大？

整体思路：
- 枚举物品 i。时间 n
- 枚举余数 j，就是把尽可能多的物品 i 装入背包，剩余的背包体积，可以理解成队列的起点。时间 v
- 滑动窗口，窗口大小 s+1，以 j 为起点，直到背包体积 m。时间 m/v
- 这样总时间就是 n * m = 2e7 可以接受 

代码示例

```C++
const int N = 20010;
int n, m;
// f[N] dp 数组 g[N] 滚动数组优化 [N] 单调队列
int f[N], g[N], q[N];

int main() {
    cin >> n >> m;
    // 枚举物品
    for (int i = 0; i < n; i++) { // 时间 n
        int v, w, s;
        cin >> v >> w >> s;
        memcpy(g, f, sizeof f);
        // 枚举余数 也就是背包最终剩余体积
        for (int j = 0; j < v; j++) {  // 时间 v
            // 队列信息
            // 队列中存的是余数
            int hh = 0, tt = -1; 
            // 从余数开始滑动窗口
            // 窗口大小为 s + 1：不选 0 个 + 选 1~s 个
            for (int k = j; k <= m; k += v) { // 时间 m/v 所以总的时间就是 n * v * m / v = n * m
                // 处理队头
                if (hh <= tt && q[hh] < k - s * v) hh++;
                // 处理队尾
                // while (hh <= tt && g[q[tt]] + w * (k - q[tt]) / v <= g[k]) {
                //     tt--;
                // }
                // y 总写法 统一减掉当前下标到 j 的个数对应的价值
                // 其实两种写法本质一样，只不过我们的写法是在算真值
                // 而 y 总算了一个相对值
                while (hh <= tt && g[q[tt]] - w * (q[tt] - j) / v <= g[k] - w * (k - j) / v) {
                    tt--;
                }
                q[++tt] = k; // 把当前体积加进去
                // 根据队头计算答案：前 i-1 个物品的最大值 + 选的物品 i 的价值
                f[k] = g[q[hh]] + (k - q[hh]) / v * w;
            }
        }
    }
    
    cout << f[m] << endl; // 答案
    return 0;
}
```

## 二维费用背包

二维费用可以与 01 背包、完全背包、多重背包结合

状态表示 `f[i][j][k]`：
- 集合：所有只从前 i 个物品中选，并且总体积不超过 j，总重量不超过 k 的选法
- 属性：最大值、最小值、方案数

状态计算：根据是否选第 i 个物品进行划分
- 所有不包含物品 i 的选法。不包含物品 i 就意味着从前 i-1 个物品中选，也就是 `f[i-1][j][k]`
- 所有包含物品 i 的选法。就是 `f[i-1][j-vi][k-mi] + wi`

[8. 二维费用的背包问题](https://www.acwing.com/problem/content/8/)

二维费用 **01 背包** 问题，板子题目

代码示例

```C++
const int N = 1010, V = 110, M = 110;
int n, v, m, f[V][M];
int main() {
    cin >> n >> v >> m;
    for (int i = 0; i < n; i++) {
        int vi, mi, wi;
        cin >> vi >> mi >> wi;
        for (int j = v; j >= vi; j--) {
            for (int k = m; k >= mi; k--) {
                f[j][k] = max(f[j][k], f[j-vi][k-mi] + wi);
            }
        }
    }
    cout << f[v][m];
    return 0;
}
```

[1022. 宠物小精灵之收服](https://www.acwing.com/problem/content/description/1024/)

也是二维费用 **01 背包** 问题

[278. 数字组合](https://www.acwing.com/problem/content/280/)

题目解析：**01 背包**
- m 看成是背包容量
- 把每个数看成是一个物品，数的大小是物品体积
- 目标是求出总体积恰好等于 m 的方案数

状态表示 `f[i][j]`：
- 集合：所有只从前 i 个物品中选，且总体积恰好等于 j 的方案集合
- 属性：方案数，初始化要注意：`f[0]=1 && f[i>=1] = 0`

状态计算：
- 不选第 i 个物品的方案数：`f[i-1][j]`
- 选第 i 个物品的方案数：`f[i-1][j-vi]`
- 总方案数：`f[i][j] = f[i-1][j] + f[i-1][j-vi]`

[1019. 庆功会](https://www.acwing.com/problem/content/1021/)

价格不等于价值的 **多重背包**，简单题

[1023. 买书](https://www.acwing.com/problem/content/1025/)

**完全背包** 求方案数

[1020. 潜水员](https://www.acwing.com/problem/content/1022/)

之前的题目多考察：体积最多是 j（经典 01 背包），体积恰好是 j（求方案数）

潜水员这个题目考察：从前 i 个物品中选，且体积至少是 j 的方案的某个属性

状态表示 f[i][j][k]：
- 集合：所有从前 i 个物品中选，且氧气含量**至少**是 j，氮气含量**至少**是 k 的所有选法
- 属性：选法重量的最小值

状态计算：
- 不选第 i 件物品：f[i-1][j][k]
- 选第 i 件物品：f[i-1][j-v1i][k-v2i] + wi
- 两者计算最小值

注意：
- 在计算 f[i-1][j-v1i][k-v2i] 时，如果出现 `j - v1 < 0 or k - v2 < 0`，这些状态也是合法的
- 如：状态 f[i][j][-2] 表示：使用前 i 个物品，使得氧气含量至少是 j，氮气含量至少是 -2
- 氮气含量至少是 -2 和氮气含量为 0 是一样的（也就是不考虑氮气含量）
- 所以如果遇到 j k 是负数状态，需要使用 0 进行转移

初始化：
- `f[0][0][0] = 0; f[0][j][k] = +inf` 
- 0 件物品只能组成 f[0][0][0]，其他都是不能实现的，故为 +inf

最小值总结：
- 体积最多是 j：全部初始化为 0，v >= 0
- 体积恰好是 j：f[0] = 0, f[i>0] = inf，v >= 0
- 体积至少是 j：f[0] = 0, f[i>0] = inf，v < 0 等于 v = 0

<<<<<<< Updated upstream
[1013. 机器分配](https://www.acwing.com/problem/content/1015/)

题意：分组背包（也可以理解成多重背包）求方案数。整体思路和 **AcWing 12. 背包问题求具体方案** 一样

[426. 开心的金明](https://www.acwing.com/problem/content/428/)

非常经典的 01 背包

[487. 金明的预算方案](https://www.acwing.com/problem/content/489/)

算是一个比较经典的分组背包。在 **426. 开心的金明** 的基础之上，加一个二进制枚举选择的附件



=======
[12. 背包问题求具体方案](https://www.acwing.com/problem/content/12/)

背包问题的具体方案，其实是判断出每个物品是否被选。

根据递推公式：`f[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i])`：
- `f[i-1][j]` 不选
- `f[i-1][j-v[i]] + w[i]` 选

当我们计算出 `f[n][m]` 后，就可以倒推出来每一步的抉择：选的是哪一项？
- 去看 `f[n][m]` 等于 `f[i-1][j]` 还是 `f[i-1][j-v[i]] + w[i]`
- 或者在递推求 `f[n][m]` 时，使用一个新数组记录一下方案的选择

其实，动态规划求方案对应最短路问题求路径。 `f[i][j]` 可以看成一个点，那么具体的方案情况就对应从点 `f[0][j]` 到点 `f[n][m]` 的最短路径

为了保证字典序最小，可以使用贪心思想。物品序号从小到大进行遍历，对于序号 i 有三种情况：
- 只能选：必选
- 只能不选：必不选
- 可选可不选：为了保证字典序最小，必选

另外，为了求字典序时，可以从前向后推，需要递推求解 dp 数组时，从后向前进行。
>>>>>>> Stashed changes













