# 背包模型

## notes
基本模型 01、完全、多重（朴素+二进制优化）、分组背包 见基础课笔记

[423. 采药](https://www.acwing.com/problem/content/description/425/)

没啥好说的，非常裸的 01 背包问题

[1024. 装箱问题](https://www.acwing.com/problem/content/description/1026/)

也是一个比较裸的 01 背包问题，但是物品没有价值，根据题意物品价值==物品体积

## 多重背包（优先队列优化）

[6. 多重背包问题 III](https://www.acwing.com/problem/content/6/)

数据范围：
- N: 1000
- V: 20000
- vi, wi, si: 20000

如果使用二进制优化，时间复杂度将会是：
- 时间 = 物品个数 * 背包体积 = 1000 * log(20000) * 20000 = 2e7 * (log(20) + log(1000)) = 2e7 * 14 = 2e8

这个时间复杂度刚好会被卡住

这个时候就需要 **优先队列优化** 的多重背包了

### 优先队列优化

二进制优化，使用的是 01 背包的思想；单调队列优化，使用的是 **完全背包** 的思想

本质是：利用单调队列找区间最大值的性质，处理选择多少件（0, 1, ..., s）第 i 件物品，使得选择第 i 件物品时总价值最大？

整体思路：
- 枚举物品 i。时间 n
- 枚举余数 j，就是把尽可能多的物品 i 装入背包，剩余的背包体积，可以理解成队列的起点。时间 v
- 滑动窗口，窗口大小 s+1，以 j 为起点，直到背包体积 m。时间 m/v
- 这样总时间就是 n * m = 2e7 可以接受 

代码示例

```C++
const int N = 20010;
int n, m;
// f[N] dp 数组 g[N] 滚动数组优化 q[N] 单调队列
int f[N], g[N], q[N];

int main() {
    cin >> n >> m;
    // 枚举物品
    for (int i = 0; i < n; i++) { // 时间 n
        int v, w, s;
        cin >> v >> w >> s;
        memcpy(g, f, sizeof f);
        // 枚举余数 也就是背包最终剩余体积
        for (int j = 0; j < v; j++) {  // 时间 v
            // 队列信息
            // 队列中存的是余数
            int hh = 0, tt = -1; 
            // 从余数开始滑动窗口
            // 窗口大小为 s + 1：不选 0 个 + 选 1~s 个
            for (int k = j; k <= m; k += v) { // 时间 m/v 所以总的时间就是 n * v * m / v = n * m
                // 处理队头
                if (hh <= tt && q[hh] < k - s * v) hh++;
                // 处理队尾
                // while (hh <= tt && g[q[tt]] + w * (k - q[tt]) / v <= g[k]) {
                //     tt--;
                // }
                // y 总写法 统一减掉当前下标到 j 的个数对应的价值
                // 其实两种写法本质一样，只不过我们的写法是在算真值
                // 而 y 总算了一个相对值
                while (hh <= tt && g[q[tt]] - w * (q[tt] - j) / v <= g[k] - w * (k - j) / v) {
                    tt--;
                }
                q[++tt] = k; // 把当前体积加进去
                // 根据队头计算答案：前 i-1 个物品的最大值 + 选的物品 i 的价值
                f[k] = g[q[hh]] + (k - q[hh]) / v * w;
            }
        }
    }
    
    cout << f[m] << endl; // 答案
    return 0;
}
```

## 二维费用背包

二维费用可以与 01 背包、完全背包、多重背包结合

状态表示 `f[i][j][k]`：
- 集合：所有只从前 i 个物品中选，并且总体积不超过 j，总重量不超过 k 的选法
- 属性：最大值、最小值、方案数

状态计算：根据是否选第 i 个物品进行划分
- 所有不包含物品 i 的选法。不包含物品 i 就意味着从前 i-1 个物品中选，也就是 `f[i-1][j][k]`
- 所有包含物品 i 的选法。就是 `f[i-1][j-vi][k-mi] + wi`

[8. 二维费用的背包问题](https://www.acwing.com/problem/content/8/)

二维费用 **01 背包** 问题，板子题目

代码示例

```C++
const int N = 1010, V = 110, M = 110;
int n, v, m, f[V][M];
int main() {
    cin >> n >> v >> m;
    for (int i = 0; i < n; i++) {
        int vi, mi, wi;
        cin >> vi >> mi >> wi;
        for (int j = v; j >= vi; j--) {
            for (int k = m; k >= mi; k--) {
                f[j][k] = max(f[j][k], f[j-vi][k-mi] + wi);
            }
        }
    }
    cout << f[v][m];
    return 0;
}
```

[1022. 宠物小精灵之收服](https://www.acwing.com/problem/content/description/1024/)

也是二维费用 **01 背包** 问题

[278. 数字组合](https://www.acwing.com/problem/content/280/)

题目解析：**01 背包**
- m 看成是背包容量
- 把每个数看成是一个物品，数的大小是物品体积
- 目标是求出总体积恰好等于 m 的方案数

状态表示 `f[i][j]`：
- 集合：所有只从前 i 个物品中选，且总体积恰好等于 j 的方案集合
- 属性：方案数，初始化要注意：`f[0]=1 && f[i>=1] = 0`

状态计算：
- 不选第 i 个物品的方案数：`f[i-1][j]`
- 选第 i 个物品的方案数：`f[i-1][j-vi]`
- 总方案数：`f[i][j] = f[i-1][j] + f[i-1][j-vi]`

[1019. 庆功会](https://www.acwing.com/problem/content/1021/)

价格不等于价值的 **多重背包**，简单题

[1023. 买书](https://www.acwing.com/problem/content/1025/)

**完全背包** 求方案数

[1020. 潜水员](https://www.acwing.com/problem/content/1022/)

之前的题目多考察：体积最多是 j（经典 01 背包），体积恰好是 j（求方案数）

潜水员这个题目考察：从前 i 个物品中选，且体积至少是 j 的方案的某个属性

状态表示 f[i][j][k]：
- 集合：所有从前 i 个物品中选，且氧气含量**至少**是 j，氮气含量**至少**是 k 的所有选法
- 属性：选法重量的最小值

状态计算：
- 不选第 i 件物品：f[i-1][j][k]
- 选第 i 件物品：f[i-1][j-v1i][k-v2i] + wi
- 两者计算最小值

注意：
- 在计算 f[i-1][j-v1i][k-v2i] 时，如果出现 `j - v1 < 0 or k - v2 < 0`，这些状态也是合法的
- 如：状态 f[i][j][-2] 表示：使用前 i 个物品，使得氧气含量至少是 j，氮气含量至少是 -2
- 氮气含量至少是 -2 和氮气含量为 0 是一样的（也就是不考虑氮气含量）
- 所以如果遇到 j k 是负数状态，需要使用 0 进行转移

初始化：
- `f[0][0][0] = 0; f[0][j][k] = +inf` 
- 0 件物品只能组成 f[0][0][0]，其他都是不能实现的，故为 +inf

最小值总结：
- 体积最多是 j：全部初始化为 0，v >= 0
- 体积恰好是 j：f[0] = 0, f[i>0] = inf，v >= 0
- 体积至少是 j：f[0] = 0, f[i>0] = inf，v < 0 等于 v = 0

[12. 背包问题求具体方案](https://www.acwing.com/problem/content/12/)

背包问题的具体方案，其实是判断出每个物品是否被选。

根据递推公式：`f[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i])`：
- `f[i-1][j]` 不选
- `f[i-1][j-v[i]] + w[i]` 选

当我们计算出 `f[n][m]` 后，就可以倒推出来每一步的抉择：选的是哪一项？
- 去看 `f[n][m]` 等于 `f[i-1][j]` 还是 `f[i-1][j-v[i]] + w[i]`
- 或者在递推求 `f[n][m]` 时，使用一个新数组记录一下方案的选择

其实，动态规划求方案对应最短路问题求路径。 `f[i][j]` 可以看成一个点，那么具体的方案情况就对应从点 `f[0][j]` 到点 `f[n][m]` 的最短路径

为了保证字典序最小，可以使用贪心思想。物品序号从小到大进行遍历，对于序号 i 有三种情况：
- 只能选：必选
- 只能不选：必不选
- 可选可不选：为了保证字典序最小，必选

另外，为了求字典序时，可以从前向后推，需要递推求解 dp 数组时，从后向前进行。

[1013. 机器分配](https://www.acwing.com/problem/content/1015/)

题意：分组背包（也可以理解成多重背包）求方案数。整体思路和 **AcWing 12. 背包问题求具体方案** 一样

[426. 开心的金明](https://www.acwing.com/problem/content/428/)

非常经典的 01 背包

[487. 金明的预算方案](https://www.acwing.com/problem/content/489/)

算是一个比较经典的分组背包。在 **426. 开心的金明** 的基础之上，加一个二进制枚举选择的附件

[1021. 货币系统](https://www.acwing.com/problem/content/1023/)

经典的 **完全背包**，恰好装满的方案数。方案数有可能很大，注意使用 long long

[532. 货币系统](https://www.acwing.com/problem/content/534/)

> 2018 NOIP 提高组

题意：给定一个货币系统 (n, a)，求出一个等价的货币系统 (m, b)，使得 m 最小，要发现两个性质：
- `a1, a2, ..., a[i], ..., a[n]` 一定可以被表示出来
- 在最优解中，`b1, ..., b[i], ..., b[n]` 一定都是从 `a1, ..., a[i], ..., a[n]` 中选择的
- `b1, ..., b[i], ..., b[n]` 一定不能被其他 `b[i]` 表示出，否则就不是最优解

那么针对这个题目：
- 可以先对 a 排序，然后从小到大排序，再遍历这些数
- 如果一个数可以由其他的数表示，那这个数就可以不选
- 如果一个数无法由其他的数表示，那这个数就必须选
- 所以，这个题目的答案就是固定的，而不是最优化的或者贪心的

问题转化成了，对于 `a[i]` 判断是否能够由前面的数表示出来？
- 答案很显然，是一个经典的 **完全背包** 问题：判断当前的钱数 `a[i]` 能否由之前的金额组成
- 能否组成的问题，可以转化为判断组成方案是否为零？如果为零，表示无法组成；如果不为零表示可以组成
- 也可以用 bool 数组表示

[7. 混合背包问题](https://www.acwing.com/problem/content/7/)

混合背包，三种背包的混合：01、完全、多重。在计算 dp 数组时，只需要判断当前物品属于哪个背包模型即可

[10. 有依赖的背包问题](https://www.acwing.com/problem/content/10/)

背包 + 树形 dp

状态表示`f[u][j]`： 
- 集合：所有以 u 为根的子树中选，且总体积不超过j 的方案
- 属性：最大值

状态计算：
- 根节点必选
- 然后考虑每棵子树的选法：看成一个分组背包问题
- 对于每一棵子树 u，我们把它看成一个物品组：根据体积 m 划分成 m 个物品：`f[u][j]`
- 然后在每个组内枚举选哪个物品就好了
- 注意：如果是按照 dfs 思路来，枚举选子树（假设当前有 n 个子树）的时间复杂度将是 O(2^n)；如果按照分组背包的思路，时间复杂度是 O(n*m)，大大减少了时间复杂度

[11. 背包问题求方案数](https://www.acwing.com/problem/content/11/)

不是恰好装满的方案数，而是`最大价值的方案数`

类似于之前求具体方案的分析，方案数 `g[i][j]` 要根据 `f[i][j]` 的转移情况选择：
- 如果 `f[i-1][j]` 大于 `f[i-1][j-vi] + wi`，则表示 `f[i][j]` 由 `f[i-1][j]` 转移过来，那么 `g[i][j] = g[i-1][j]`
- 如果 `f[i-1][j]` 小于 `f[i-1][j-vi] + wi`，则表示 `f[i][j]` 由 `f[i-1][j-vi] wi` 转移过来，那么 `g[i][j] = g[i-1][j-vi]`
- 如果 `f[i-1][j]` 等于 `f[i-1][j-vi] + wi`，则表示两种情况都可以转移到 `f[i][j]`，那么 `g[i][j] = g[i-1][j] + g[i-1][j-vi]`
- 这个题目不必反着求了，g 数组跟着 dp 数组一起求即可

注意：
- 题目求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
- dp 数组的含义是恰好装满，所以最大值最后要遍历一遍 f 数组
- 题解区也有另一种体积不超过 j 的 dp 数组定义写法

[734. 能量石](https://www.acwing.com/problem/content/736/)

考虑两个方面：
- 吃哪些能量石？
- 吃这些能量石的顺序？

考虑相邻的两个能量石，怎么吃最优？贪心的思路：
- 比较先吃第一块的能量：`e1 + e2 - l2 * s1` 和先吃第二块的能量：`e1 + e2 - l1 * s2`
- 吃的顺序肯定要让能量最大，也就是先吃第一块的能量大于先吃第二块即：`l2 * s1 < l1 * s2` 的顺序吃能量石
- 先按照这个顺序对能量石排序

确定了吃的顺序，剩下就是吃哪些石头获得的能量最大：01 背包，暴力计算结果！

状态表示：
- 集合：所有从前 i 块能量石中选，且总体恰好是 j 的方案
- 属性：最大值

状态计算：
- 01 背包状态转移：`f[i][j] = max(f[i-1][j], f[i][j-s] + e - (j-s)*l)`
- 其中，`e - (j-s)*l)` 表示到 j 时刻吃这个物品 i 时，还剩下的能量

