# 树形 DP

对于无权树，求树的直径，非常经典的做法：
- 任取一点作为起点，找到距离该点最远的一个点 u
- 再使用 DFS 或者 BFS 找到距离 u 最远的一点 v
- 那么 u 和 v 之间的路径就是一条直径

对于有边权的树：使用树形 DP，但是个人感觉这个还不能算是 dp，只能算一个 dfs

[1072. 树的最长路径](https://www.acwing.com/problem/content/1074/)


[1073. 树的中心](https://www.acwing.com/problem/content/1075/)

两遍 dfs ：
- 第一次 dfs 计算向下走的最大值，记录两个，更新答案
- 第二次 dfs 计算向上走的最大值，并更新答案

[1075. 数字转换](https://www.acwing.com/problem/content/1077/)

转换成在一堆树中找到一个最长路径：1072. 树的最长路径

[1074. 二叉苹果树](https://www.acwing.com/problem/content/1076/)

有依赖的背包的化简版

[323. 战略游戏](https://www.acwing.com/problem/content/325/)

十分类似没有上司的舞会，也是一个状态机模型：
- 没有上司的舞会: 每条边上最多选择一个点。最大权值
- 战略游戏: 每条边上最少选择一个点。最小权值

状态表示 f[i][j], j = 0 or 1：
- 集合：所有在以 i 为根的子树中选，且点 i 的状态是 j 的所有选法
- 属性：最小值

状态计算：
- f[x][0] = min(f[y1][1] + f[y2][1] + ...)
- f[x][1] = min(min(f[y1][0], f[y1][1]) + min(f[y2][0], f[y2][1]) + ...)

[1077. 皇宫看守](https://www.acwing.com/problem/content/1079/)

也十分类似没有上司的舞会，是一个状态机模型

状态表示 f[i][j], j = 0 1 2：
- 集合：所有在以 i 为根的子树中选，且点 i 的状态是 j 的所有选法
    - f[x][0]：点 x 被父节点看到的条件下的最小花费
    - f[x][1]：点 x 被子节点看到的条件下的最小花费
    - f[x][2]：点 x 处放置警卫的条件下的最小花费
- 属性：最小值

状态计算：
- f[x][0] += min(f[yi][1], f[yi][2])
- f[x][2] += min(f[yi][0], f[yi][1], f[yi][2])
- f[x][1] = min{ f[yi][2] + f[x][0] - min(f[yi][1], f[yi][2])}










