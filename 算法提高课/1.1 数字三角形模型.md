# 数字三角形模型

[1015. 摘花生](https://www.acwing.com/problem/content/1017/)

状态表示 `f[i][j]`：
- 集合：所有从 `[1, 1]` 走到 `[i, j]` 的路线
- 属性：**最大值**/最小值/数量

状态计算：
- 集合的划分，考虑能够走到 `[i, j]` 的点：`[i-1, j]` 和 `[i, j-1]`，那么答案必然来自于上述两者：`f[i][j] = max(f[i-1][j], f[i][j-1]) + a[i][j]` 

```C++
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        cin >> a[i][j];
    }
}

for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        f[i][j] = max(f[i-1][j], f[i][j-1]) + a[i][j];
    }
}
cout << f[n][m] << endl;
```

[1018. 最低通行费](https://www.acwing.com/problem/content/1020/)

与摘花生一样的解法，只不过求最小值，初始化的情况不同

[1027. 方格取数](https://www.acwing.com/problem/content/1029/)

总结一下就是摘两次花生 🥜，但是同一个数只允许摘一次

状态表示：
- `f[i1][j1][i2][j2]` 表示所有从 `[1][1]` 分别走到 `[i1][j1]` 和 `[i2][j2]` 的路径的最大值
- 如何处理“同一个格子不能被重复选择”
- 只有在 `i1+j1 = i2+j2` 时，两条路径上的格子才有可能重合
- 所以使用 `f[k][i1][i2]` 表示所有从 `[1][1]` 分别走到 `[i1][k-i1]` 和 `[i2][k-i2]` 的路径的最大值
- `k` 表示两条路径当前走到的格子的横纵坐标之和，`k = i1+j1 = i2+j2`

状态计算：
- `f[k][i1][i2]` 表示两条路径，所以就会有 4 种来源：
    - 第一条：下；第二条：下
    - 第一条：下；第二条：右
    - 第一条：右；第二条：下
    - 第一条：右；第二条：右
- 如果是第一类：“第一条：下；第二条：下”，可以这样表示：
    - `[1][1] => [i1-1][j1] -> [i1][j1]`
    - `[1][1] => [i2-1][j2] -> [i2][j2]`
    - 上面的 `=>` 表示很多条路径 `->` 表示一条路径
    - 则 `f[k][i1][i2] = max(f[k-1][i1-1][i2-1]) + w[i1][j1] + w[i2][j2]`，注意如果点 `[i1][j1]` 和 `[i2][j2]` 重合了只加一个权重。
- `f[k][i1][i2]` 最终的值就是四种来源里面的最大值

示例代码

```C++
int n, a[N][N], f[2*N][N][N];

int main() {

    cin >> n;

    int x, y, z;
    while (cin >> x >> y >> z, x || y || z) {
        a[x][y] = z;
    }

    for (int k = 2; k <= 2*n; k++) {
        for (int i1 = 1; i1 <= n; i1++) {
            for (int i2 = 1; i2 <= n; i2++) {
                int j1 = k - i1, j2 = k - i2;
                if (0 < j1 && 0 < j2 && j1 <= n && j2 <= n) {
                    int& x = f[k][i1][i2];
                    int t = a[i1][j1];
                    if (i1 != i2) t += a[i2][j2];
                    x = max(x, f[k-1][i1-1][i2-1] + t);
                    x = max(x, f[k-1][i1-1][i2] + t);
                    x = max(x, f[k-1][i1][i2-1] + t);
                    x = max(x, f[k-1][i1][i2] + t);
                }
            }
        }
    }
    cout << f[2*n][n][n];
    return 0;
}
```













