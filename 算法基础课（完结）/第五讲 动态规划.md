#! https://zhuanlan.zhihu.com/p/654611139
# 动态规划

## 下标注意

当涉及 `[i-1]` 这种下标时，下标一般从 `1` 开始，这样 `i-1 = 0`，不会越界；如果没涉及 `[i-1]` 这种下标，下标从 0 开始就行

## 时间复杂度

动态规划的时间复杂度 = 状态数量 * 转移计算量

## 背包问题

### 01 背包

有 N 件物品和一个容量是 V 的背包。**每件物品只能使用一次**。第 i 件物品的体积是 vi，价值是 wi。

求：将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值

#### 状态表示

用两维的状态来表示 `f[i][j]`，再细分成：表示的集合和集合的属性。这里 `f[i][j]` 代表的集合是：背包容量是 j 的情况下，从前 i 个物品中选物品的选法。属性一般有三种：最大值、最小值、数量，在这里 `f[i][j]` 的属性就是最大值

那么答案就是 `f[N][V]`，表示集合 { 背包容量是 V 的情况下，从前 N 个物品中选物品的选法 } 的最大值

#### 状态计算

对应集合的划分，将 `f[i][j]` 划分成两大类：不选 i 的选法和选 i 的选法，划分要保证不重不漏（求最大值重复也没问题，个数要求不重复）。

1. 不选 i 的选法：从前 i 个物品中选物品，而且不选 i，其实就是从前 i-1 个物品中选物品，总体积不超过 j，也就是 `f[i-1][j]`
2. 选 i 的选法：首先选物品 i，则价值就要加上 wi，但是背包体积就变成了 j - vi。问题就变成了：背包容量是 j - vi 的情况下，从前 i - 1 个物品中选物品的选法。因此最大值就是：`f[i-1][j-vi] + wi`，注意此种选法的前提是**背包容量能够容得下物品 i**，所以要进行判断

`f[i][j]` 应该是上述两种情况的最大值：`f[i][j] = max(f[i-1][j], f[i-1][j-vi] + wi)`

#### 初始化 or 边界

初始化 `f[0][0] ~ f[0][m]` 的值，其他的值可以通过递推公式求出。考虑其实际意义：`f[0]` 表示一件物品也没法选，那么其最大价值固然为零，故 `f[0][i] = 0`，全局变量的默认初值

#### 一维代码

根据状态转移方程：`f[i][j] = max(f[i-1][j], f[i-1][j-vi] + wi)`，`f[i]` 只用到了 `f[i-1]`，同时发现 `f[i-1][j]` 和 `f[i-1][j-vi] + wi` 的第二维都是 `<= j` 的，在同一侧，故我们可以使用一维数组优化。为了保证数据不被覆盖，我们需要从右向左计算（倒序）

```C++
for (int i = 1; i <= n; i++) {
    for (int j = m; j >= v[i]; j--) {
        f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
}
```

### 完全背包

有 N 种物品和一个容量是 V 的背包，**每种物品都有无限件可用**。第 i 种物品的体积是 vi，价值是 wi

求：将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值

#### 状态表示

状态 `f[i][j]` 代表的集合：背包容量是 j 的情况下，从前 i 个物品中选物品的选法。属性是最大值

那么答案就是 `f[N][V]`，表示集合 { 背包容量是 V 的情况下，从前 N 个物品中选物品的选法 } 的最大值

#### 状态计算

集合 `f[i][j]` 的划分，首先将 `f[i][j]` 划分成两大类：不选 i 的选法和选 k 个物品 i 的选法

1. 不选 i 的选法：从前 i 个物品中选物品，而且不选 i，其实就是从前 i-1 个物品中选物品，总体积不超过 j，也就是 `f[i-1][j]`
2. 选 k 个物品 i 的选法：假设此种情况有选 1、2、...、k-1、k 个物品，那么这些选法的最大值就是：`max(f[i-1][j-k*vi]) + k*wi`。

综合来看，上述两种选法其实可以归纳为一种：选 k 个物品 i 的选法，k 可以取 0、1、2、...、k-1、k 个物品。这样算法在枚举完物品、体积之后还要枚举选物品 i 的个数 k 的值，故将会是一个 n^3 的算法。

优化成 n^2 的算法：

求：`f[i][j] = max(f[i-1][j], f[i-1][j-v] + w, f[i-1][j-2v] + 2w, ...)`

有：`f[i][j-v] = max(f[i-1][j-v], f[i-1][j-2v] + w, f[i-1][j-3v] + 2w, ...)`

可以发现：`f[i][j-v] + w = f[i-1][j-v] + w, f[i-1][j-2v] + 2w, ...`

故，`f[i][j] = max(f[i-1][j], f[i][j-v] + w)`，就把最后一层的 `for` 循环优化成了 2 个状态，总的时间复杂度变为了 O(n^2)。注意还是要判断能否装得下物品体积 v。 

#### 一维代码

可以进行一维优化（分析同 01 背包）。但是，完全背包内层循环正序遍历就行，因为 `f[i][j-v]` 中的 `f[i]` 表示本行而不是 01 背包中的 `f[i-1]`（表示上一行）

```C++
for (int i = 1; i <= n; i++) {
    for (int j = v[i]; j <= m; j++) {  // 代码上与 01 背包只有这一点不同
        f[j] = max(f[j], f[j-v[i]] + w[i]);
    }
}
```

### 多重背包

有 N 种物品和一个容量是 V 的背包。**第 i 种物品最多有 si 件**，每件体积是 vi，价值是 wi

求：将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值

#### 状态表示

状态 `f[i][j]` 表示集合：所有只从前 i 个物品中选，并且总体积不超过 j 的选法。并且状态的属性是**最大值**

#### 状态计算

`f[i][j] = max(f[i-1][j-k*vi]+k*wi)`，其中 k 表示第 i 个物品选多少个：`0 ~ s[i]`，这样就是一个 n^3 的暴力做法：枚举物品 i、枚举体积 j、枚举选几个物品 k。

#### 二进制优化

为什么不能优化成完全背包那样？完全背包中物品的个数是无限的，而多重背包是有限的，这有本质的区别：完全背包的优化工公式不再成立

**采用二进制优化**：把第 i 种物品打包，然后把这些打包的物品看作不同的物品。并且按照 2 的幂次进行打包：1 个 i 种物品、2 个 i 种物品、...、2^k 个 i 种物品，可以发现，当使用 2 的幂次进行打包时，**可以凑出任何数量的第 i 种物品！**那这样可以套用 01 背包的方式，枚举选或者不选和这些打包好的**新物品**，从而得到一个 n^2*logn 的算法

```C++
// N 的值取 1000*log(2000) 就可以 最多有这些数
const int N = 12007, M = 2007;  

// 边读入数据 边进行二进制拆分
int cnt = 0;
for (int i = 1; i <= n; i++) {
    int a, b, s;
    cin >> a >> b >> s;
    int k = 1;
    while (k <= s) {
        cnt++;
        v[cnt] = a * k;
        w[cnt] = b * k;
        s -= k;
        k *= 2;
    }
    if (s > 0) {
        cnt++;
        v[cnt] = a * s;
        w[cnt] = b * s;
    }
}

// 01 背包模板
n = cnt;
for (int i = 1; i <= n; i++) {
    for (int j = m; j >= v[i]; j--) {
        f[j] = max(f[j], f[j-v[i]] + w[i]);
    }
}
```

### 分组背包

有 N 组物品和一个容量是 V 的背包。每组物品有若干个，**同一组内的物品最多只能选一个**。每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。

求：将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值

#### 状态表示

状态 `f[i][j]` 表示集合：只从前 i 组物品中选，且总体积不大于 j 的所有选法集合。属性是最大值

#### 状态计算

`f[i][j] = max(f[i-1][j], f[i-1][j-vik] + wik)`，解释：f[i][j] 表示要么不选，要么选第 i 组的第 k 个物品，因为要枚举 k，故这是一个 n^3 的算法

```C++
// 枚举物品组
for (int i = 1; i <= n; i++) {
    int s;
    cin >> s;
    // 读入数量 并读入这一组数据  也可以使用二维数组
    for (int j = 0; j < s; j++) cin >> v[j] >> w[j];
    // 枚举体积
    for (int j = m; j >= 0; j--) {
        // 枚举选哪一个
        for (int k = 0; k < s; k++) {
            if (j >= v[k]) f[j] = max(f[j], f[j-v[k]] + w[k]);
        }
    }
}
```

## 线性 DP

定义：递推方程的计算，有明显的线性顺序

### **最经典的线性 DP 问题 1：**[898. 数字三角形](https://www.acwing.com/problem/content/900/)

给定一个数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

#### 状态表示

`f[i][j]` 表示的集合是：所有从起点出发，走到点 `[i][j]` 的路径集合。属性就是路径上所有数字之和的最大值。

#### 状态计算

考虑可以到达 `[i][j]` 的点：`[i-1][j-1]`，`[i-1][j]`，那么我们的状态 `f[i][j]` 也必然是从状态 `f[i-1][j-1]` 和 `f[i-1][j]` 转移过来的。

`f[i][j] = max(f[i-1][j-1], f[i-1][j]) + w[i][j]`

那么答案就是：`max(f[-1][i])`，即到达底层数字之和的最大值

### **最经典的线性 DP 问题 2.1：**[895. 最长上升子序列](https://www.acwing.com/problem/content/897/)

给定一个长度为 `N` 的数列，求数值严格单调递增的子序列的长度最长是多少。

数据范围：$1 \le N \le 1000, −10^9 \le 数列中的数 \le 10^9$

#### 状态表示

要注意到以最后一个数字结尾的子序列，不一定是该数列的最长严格单调递增子序列，数列中任何一个数字都有可能成为这个子序列的最后一个元素。

那么，状态 `f[i]` 就表示以第 `i` 个数字结尾的严格单调递增子序列的集合。

属性就是集合内所有子序列长度的最大值

#### 状态计算

枚举哪些数 `a[j]` 可以转移到 `a[i]`，注意到 `j < i`，且 `a[j] < a[i]`

`f[i] = max(f[j] + 1)`

那么答案就是：`max(f[i])`，即所有最大长度中的最大值

#### 保存最长序列

记录一下：每一个数字是如何转移的，也就是前一个数字的下标位置

### **最经典的线性 DP 问题 2.2：**[896. 最长上升子序列 II](https://www.acwing.com/problem/content/description/898/)

给定一个长度为 `N` 的数列，求数值严格单调递增的子序列的长度最长是多少。

数据范围：$1 \le N \le 100000, −10^9 \le 数列中的数 \le 10^9$，相比上一题，本题的数据范围扩大了，n^2 的算法会超时。

#### 核心思想

维护每一种长度的上升子序列的**最小结尾数字**，那么答案就是所维护到的的最大长度。显然，随着**长度的增加结尾的数字在严格单调递增**

当处理到元素 `ai` 时，可以**二分**找到比 `ai` 小的最大的数 `bi`，则 `ai` 能构成的最大的长度 = `bi` 对应的长度 + 1，然后更新长度对应的元素为 `ai`。或者说，**二分**找到大于等于 `ai` 的第一个数，然后用 `ai` 更新这个数，当然如果没有大于等于 `ai` 的数，意味着 `ai` 可以组成目前长度最长的子序列。

#### 代码示例

```C++
cin >> n;
q[0] = -2e9;  // 哨兵，并且不算长度
for (int i = 0; i < n; i++) {
    int a;
    cin >> a;  // 读入 a
    // 二分模板 找到 q 中第一个大于等于 a 的下标 这里其实不写也行
    int l = 1, r = len;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (q[mid] < a) l = mid + 1;
        else r = mid - 1;
    }
    // 用这个下标更新长度
    len = max(len, l);
    // 更新 q 中的值
    q[l] = a;
}
cout << len << endl;
```

### **最经典的线性 DP 问题 3：**[897. 最长公共子序列](https://www.acwing.com/problem/content/899/)

给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。

数据范围：$1 \le N, M \le 1000$

#### 状态表示

状态 `f[i][j]` 表示：第一个序列的前 i 个字母与第二个序列的前 j 个字母的公共子序列集合

属性是集合中公共子序列长度的最大值

#### 状态计算

以 `a[i]` 和 `b[j]` 选或者不选来进行划分，也即四种情况：

1. 都不选，即 `f[i-1][j-1]`，注意这一类会被包含在 2 3 情况中，一般不写
2. 选 `a[i]`，不选 `b[j]`，此时对应的状态应该是 `f[i-1][j]`
3. 不选 `a[i]`，选 `b[j]`，此时对应的状态应该是 `f[i][j-1]`
4. 都选，即 `f[i-1][j-1] + 1`

注意：我的理解是 2 和 3 与 4 是互斥的。如果 `a[i] = b[j]`，肯定是 4 都选最优；否则结果应该是 2 和 3 中的最大值。y 总是：先找到 2 和 3 中的最大值，如果 `a[i] = b[j]` 相等，再用 4 更新一下结果。 

答案就是 `f[n][m]`

### **最经典的线性 DP 问题 4：**[902. 最短编辑距离](https://www.acwing.com/problem/content/904/)

给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：

1. 删除–将字符串 A 中的某个字符删除。
2. 插入–在字符串 A 的某个位置插入某个字符。
3. 替换–将字符串 A 中的某个字符替换为另一个字符。

现在请你求出，将 A 变为 B 至少需要进行多少次操作。

#### 状态表示

状态 `f[i][j]` 表示：所有将 `a[1~i]` 变成 `b[1~j]` 的操作方式

属性是这些所有操作方式的操作次数中的最小值

#### 状态计算

能够转移到 `f[i][j]` 的状态有：

- 考虑把 `a[i]` 删掉，这样只需实现 `f[i-1][j]`，`f[i][j] = f[i-1][j] + 1`
- 考虑在 `a[i]` 后面添加 `b[j]`，这样只需 实现 `f[i][j-1]`，`f[i][j] = f[i][j-1] + 1`
- 考虑将 `a[i]` 换成 `b[j]`，这样只需实现 `f[i-1][j-1]`，`f[i][j] = f[i-1][j-1] + 1`，注意：如果 `a[i]` 已经等于 `b[j]`，那么就不用加 1 了，也即 `f[i][j] = f[i-1][j-1]`

代码示例
```C++
cin >> n >> a + 1;
cin >> m >> b + 1;
// 边界条件
for (int j = 0; j <= m; j++) f[0][j] = j;
for (int i = 0; i <= n; i++) f[i][0] = i;
// 递推
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        f[i][j] = min(f[i-1][j], f[i][j-1]) + 1;
        f[i][j] = min(f[i][j], f[i-1][j-1] + (a[i] != b[j]));
    }
}
cout << f[n][m] << endl;
```

## 区间 DP

### [282. 石子合并](https://www.acwing.com/problem/content/284/)

设有 N 堆石子排成一排，其编号为 1,2,3,…,N。

每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N 堆石子合并成为一堆。

每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

问题是：找出一种合理的方法，使总的代价最小，输出最小代价。

### 问题分析

目标是合并区间 `[i, j]`，但每次只能合并相邻的两堆石子，这意味着需要把 `[i, j]` 分成两大堆石子 `[i, k]` 和 `[K+1, j]`，最终的代价就是：分别合并两大堆石子 `[i, k]` 和 `[k+1, j]` 各自的代价，加上合并他们的总代价（也即，区间 `[i, j]` 的和）

### 状态表示

状态 `f[i][j]` 表示：所有将第 `i` 堆石子到第 `j` 堆石子合并成一堆石子的合并方式

属性是所有合并方式代价的最小值

### 状态表示

最后肯定是合并两堆。枚举区间 `[i][j]` 的划分：`[i][k]` 和 `[k+1][j]`，则状态转移公式：`f[i][j] = f[i][k] + f[k+1][j] + s[j] - s[i-1]`

### 递推公式

```C++
// 枚举 k from i to j-1
// f[i][j] 合并区间 [i, j] 的最小代价
// s[j] - s[i-1] 区间 [i, j] 的和
f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j] - s[i-1]);
```

### 代码

```C++
// 记搜
int n, a[N], s[N], f[N][N];
memset(f, -1, sizeof f);

int dfs(int i, int j) {
    if (f[i][j] != -1) return f[i][j];

    if (i == j) return f[i][j] = 0;
    // 枚举拆分成两个区间的位置
    // [i, j]->[i, k]和[k+1, j]
    int res = INF;
    for (int k = i; k < j; k++) {
        res = min(res, dfs(i, k) + dfs(k+1, j) + s[j] - s[i-1]);
    }
    return f[i][j] = res;
}
// 递推
// 先枚举区间长度 先把各种小的区间计算出来，才能计算大区间
// 长度为 1 的区间 f[i][j] = 0
for (int len = 2; len <= n; len++) {
    // 枚举区间左端点
    for (int i = 1; i + len - 1 <= n; i++) {
        // 计算区间右端点
        int j = i + len - 1;
        // 枚举拆分区间的位置
        f[i][j] = 1e9;
        for (int k = i; k < j; k++) {
            f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j] - s[i-1]);
        }
    }
}
// 输出答案
cout << f[1][n] << endl;
```

## 计数类 DP

[900. 整数划分](https://www.acwing.com/problem/content/902/)

### 方法一：转化成完全背包问题

转化👍：一个容量是 n 的背包，物品的体积分别是 1~n，每种物品有无限个，问恰好装满背包的**方案数**是多少？

```C++
// 初始化
f[0] = 1;
// 枚举物品
for (int i = 1; i <= n; i++) {
    // 枚举体积
    // 完全背包 正向枚举就行
    for (int j = i; j <= n; j++) {
        // 计算方案数
        f[j] = ((LL)f[j] + f[j-i]) % MOD;
    }
}
cout << f[n] << endl;
```

### 方法二：

#### 状态表示

`f[i][j]` 表示所有总和是 i 并且恰好分成 j 个数的和的方案的数量

#### 状态计算

`f[i][j]` 划分成**最小值是 1** 和**最小值大于 1** 的两种情况

- 最小值是 1 的情况来自于：`f[i-1][j-1]`，也就是向总和是 i-1 并且恰好分成 j-1 个数的和的方案中加一个 1，便组成了 `f[i][j]`

- 最小值大于 1 的情况来自于：`f[i-j][j]`，也就是向总和是 i-j 并且恰好分成 j 个数的和的方案中的每一个数加 1，便得到了 `f[i][j]`

`f[i][j]` 只会来自于上述两种情况，得到递推公式：`f[i][j] = f[i-1][j-1] + f[i-j][j]` 

#### 答案

答案就是 1 ~ n 所有情况的求和：`ans = f[n][1] + f[n][2] + ... + f[n][n]`

```C++
f[0][0] = 1;
// 枚举和
for (int i = 1; i <= n; i++) {
    // 枚举个数
    for (int j = 1; j <= i; j++) {
        f[i][j] = (f[i-1][j-1] + f[i-j][j]) % MOD;
    }
}
int res = 0;
for (int i = 1; i <= n; i++) res = (res + f[n][i]) % MOD;
cout << res << endl;
```

## 数位统计 DP

### 问题原型

计算数字 a ~ b 中 1 出现的次数，数据范围 `1e8`。举例：1 ~ 12 中 1 出现的次数，包含 1 的数字：1、11、10、12，则 1 出现的次数是：5

### 分析

如果暴力求解的话，时间复杂度是：1e8 * 8，肯定超时

#### 分情况讨论

举例：`1 ~ n, i, n = abcdefg` 分别求出 i 在每一位上出现的次数

先求 i 在第 4 位上出现的次数，`1 <= xxxiyyy <= abcdefg`

1. 当 xxx = 000 ~ abc-1 时，yyy 的取值无约束：000 ~ 999，则有 abc * 1000 种选法
2. 当 xxx = abc 时，再分情况讨论：

    - 若 d < i，则 abc1yyy > abc0yyy，其中 d = 0，则方案数就是 0

    - 若 d = i，yyy = 000 ~ efg，则方案数是 1 + efg
    - 若 d > i，yyy 的取值无约束：000 ~ 999，则有 1000 种选法

上述两种情况的方案数加到一起就是 i 在第 4 位上出现的次数，其实也就是第 4 位上是 i 的数的个数。

时间复杂度：枚举 8 位 * 每一位最多 10 次运算

#### 边界问题：

- 当 i 出现在最高位时：情况 1 不存在，只算第二种情况
- 在枚举 i = 0 时，由于不能有前导零，前 3 位应该从 001 开始 

### 更推荐灵神写法

```C++
int f[N][N];  // 记忆化的变量：位数 i，从高位到第 i 位记录的个数 cnt
// 当前状态（i 位，统计个数为 cnt）下，第 i 为以及后面各位统计的个数
int dfs(string& a, int i, int t, int cnt, bool is_num, bool is_limit) {
    if (i == a.size()) { // 数位枚举结束 根据选择情况返回答案
        if (is_num) return cnt; // 选了数，返回统计的 t 的数目 
        return t == 0; // 没选数，表示的数是 0，如果统计 0 的个数就返回 1
    }
    // 是否已经计算过答案
    if (is_num && !is_limit && f[i][cnt] != -1) 
        return f[i][cnt];
    
    int res = 0;
    if (!is_num) {  // 这一位不选数字
        res += dfs(a, i+1, t, cnt, false, false);
    }
    // 选数字的上下界
    int low = is_num ? 0 : 1; // 如果之前没选数字，下限从 1 开始
    int up = is_limit ? a[i] - '0' : 9;
    for (int j = low; j <= up; j++) {
        // 如果这一位填的数字等于目标数字 cnt+1
        res += dfs(a, i+1, t, cnt + (j == t), true, is_limit && j == up);
    }
    // 记忆化 注意记忆化的条件
    if (is_num && !is_limit) f[i][cnt] = res;
    return res;
}
```

## 状态压缩DP

[AcWing 291. 蒙德里安的梦想](https://www.acwing.com/activity/content/problem/content/1010/)

### 思路分析

先放横着的方块，再放竖着的方块。横着的放完，竖着的直接插进去就行。所以，方案总数等于只放横着的小方块的合法方案数。

如何判断当前方案是否合法？所有剩余位置，能否填充满竖着的小方块。可以按列来看，每一列内部所有连续的空着的小方块，需要是偶数个

### 状态表示

`f[i][j]` 表示已经将前 `i-1` 列摆好，且从第 `i-1` 列，伸出到第 `i` 列的状态是 `j` 的所有方案

举例：

`*` 表示摆好了，`-` 表示未摆放，则下述状态是 `i = 2, j = 0b11001`
```C++
   0 1 2 3 4 5
0  * * * - - - 
1  * * * - - -
2  * * - - - -
3  * * - - - -
4  * * * - - -
```
解释：第 `i-1=1` 列已经全部摆满了，从第 `i-1=1` 列，伸出到第 `i=2` 列的状态是 `11001`

### 状态计算

假设 `f[i][j]` 由 `f[i-1][k]` 转移而来，则状态 `k` 和 `j` 之间必须满足以定的关系：

- 不重叠 `(k & j) == 0`
- 所有连续空着的位置的长度必须是偶数

答案就是 `f[m][0]` 表示前 `m` 列（下标从 0 开始）全部摆满，且伸出的状态是 `0`

#### 预处理

预处理有哪些状态 k 可以更新到 j

```C++
const int N = 12, M = 1 << N;
int n, m;
LL f[N][M]; // f[i][j] 表示第 i-1 列已经填满，伸到第 i 列的状态时 j
vector<int> state[M];  // state[i] 中存能够转移到 i 的状态
bool st[M]; // st[i] 表示状态 i 是否合法

int main() {

    while (cin >> n >> m, n || m) {
        // 预处理 合法状态
        for (int i = 0; i < 1 << n ; i++) {
            int cnt = 0;
            bool is_valid = true;
            for (int j = 0; j < n; j++) {
                if (i >> j & 1) {
                    if (cnt & 1) {
                        is_valid = false;
                        break;
                    } 
                    cnt = 0;
                } else cnt++;
            }
            if (cnt & 1) is_valid = false;
            st[i] = is_valid;
        }
        // 预处理 转移到状态 i 的状态 j
        for (int i = 0; i < 1 << n; i++) {
            state[i].clear();
            for (int j = 0; j < 1 << n; j++) {
                if ((i & j) == 0 && st[i|j])
                    state[i].push_back(j);
            }
        }
        
        memset(f, 0, sizeof f);
        f[0][0] = 1;  // 初始时，第 -1 列填满，且伸到 0 列的状态是 0，此种方案只有啥也不填这一种
        for (int i = 1; i <= m; i++) {
            for (int j = 0; j < 1 << n; j++) {
                for (int k: state[j]) {
                    f[i][j] += f[i-1][k];
                }
            }
        }
        // 答案就是 m-1 列填满，且伸到 m 列的状态是 0
        cout << f[m][0] << endl;
    }
    return 0;
}
```

[91. 最短Hamilton路径](https://www.acwing.com/problem/content/93/)

> 又名，旅行商问题。一个 NP 完全问题：计算机没办法在多项式时间内求出问题的解

#### 核心思路

1. 哪些点被用过
2. 目前停在哪个点上

状态的数量：用过的点的状态 `2^20 * 20` 个点

### 状态表示

`f[state][j]` 表示，当前 state 下，停在了 j 点上

### 状态计算

`f[state][j] = f[state_k][k] + w[k][j]`，解释：`state_k + j = state`，也即，`state_k` 表示 `state` 除掉 `j` 这个点之后的集合，且 `state_k` 包含 `k`

时间复杂度：状态的数量 * 20 个点 = `2^20 * 20 * 20`，解释：所有状态的数量更新其余 20 个点

答案就是 `f[(1 << n) - 1][n-1]`，遍历所有的状态，且最终点在 n - 1 上

```C++
const int N = 20, M = 1 << N;
int n, g[N][N], f[M][N]; // f[i][j] 表示经过的点组成状态 i，最后一个点是 j 时的最短路
int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> g[i][j];
        }
    }
    // 初始化
    memset(f, 0x3f, sizeof f);
    f[1][0] = 0; // 从 0 出发 经过 0 到达 0 的距离是 0
    for (int i = 1; i < 1 << n; i++) {  // 枚举状态
        for (int j = 0; j < n; j++) { // 枚举终点 j
            if (i >> j & 1) {
                for (int k = 0; k < n; k++) {  // 枚举上一个点 k
                    if ((i ^ (1 << j)) >> k & 1) {
                        f[i][j] = min(f[i][j], f[i ^ (1 << j)][k] + g[k][j]);
                    }
                }
            }
        }
    }
    cout << f[(1 << n) - 1][n-1]; // 答案是经过 n 个点 最终到 n-1 的最短路
    
    return 0;
}
```

## 树形 DP

[285. 没有上司的舞会](https://www.acwing.com/problem/content/287/)

### 状态表示

`f[u][0]` 表示从所有以 u 为根的子树中选择，并且不选 u 这个点的方案数

`f[u][1]` 表示从所有以 u 为根的子树中选择，并且选 u 这个点的方案数

属性: `max`

### 状态计算

假设 u 的儿子：s1, s2, ..., si, ...

`f[u][0]` 应当是子树取最大

- `f[u][0] += max(f[si][0], f[si][1])`

`f[u][1]` 只能是不选儿子节点情况下取最大

- `f[u][1] += f[si][0]`

时间复杂度：O(n)

```C++
int n, ha[N], f[N][2];
bool has_fa[N];
int h[N], e[N], ne[N], idx;

void add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

void dfs(int x) {
    f[x][1] = ha[x];  // 选根节点 加上他的快乐值
    for (int i = h[x]; ~i; i = ne[i]) {
        int y = e[i];
        dfs(y);
        
        f[x][0] += max(f[y][0], f[y][1]);  // 不选根节点 加孩子节点（两种情况）的最大值
        f[x][1] += f[y][0]; // 选根节点 就不能选孩子了
    }
}

int main() {
    
    memset(h, -1, sizeof h);
    
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> ha[i];
    for (int i = 1; i < n; i++) {
        int l, k;
        cin >> l >> k;
        has_fa[l] = true;
        add(k, l);
    }
    
    int root = -1;
    for (int i = 1; i <= n; i++) {
        if (!has_fa[i]) {
            root = i;
            break;
        }
    }
    dfs(root);
    
    cout << max(f[root][0], f[root][1]);
    return 0;
}
```







