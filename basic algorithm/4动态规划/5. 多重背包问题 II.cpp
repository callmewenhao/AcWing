/**
 * 使用 二进制优化
 * 这个题目的数据范围是：1000，不能使用 n^3 的算法
 * 
 * 使用 二进制 拆分 s，拆分后的物品整体上认为是一个 01 背包问题
 * 再套用 01 背包模板，整体的时间复杂度是 n^2 * logn 的算法
 * 
 * 拆分思路：
 * 前面 n^3 的算法其实也是在拆分 s，但是，是把 s 拆成 s 个 1，一共 s 项
 * 借助 二进制 我们可以把 s 拆成 2 的幂，比如：s = 1 + 2 + 4 + 8 + ...
 * 这样一共就 log(s) 项，时间复杂度大大降低
 * 
 * 还需考虑这样一个问题，并不是所有的 s 都是 2 的整次幂，比如：s=10 时
 * 这个时候就需要特殊处理，分成：s = 1 + 2 + 4 + 3
 * 这样整体的值域就是 0~10 了
 * 
 * 还有一点要注意：
 * 选择之间是有重合的，比如选 1+2 和选 3，选到的数据都是 3，选 1+4 和 2+3，选到的数目都是 5
 * 这样不会影响到求最大最小值，但是会影响到求方案数，毕竟方案数是求和不是求 max
 * 
*/

#include <iostream>

using namespace std;

const int N = 12007, M = 2007;  // N 的值取 1000*log(2000) 就可以 最多有这些数

int n, m;
int v[N], w[N], f[M];

int main() {

    cin >> n >> m;

    // 边读入数据 边进行二进制拆分
    int cnt = 0;
    for (int i = 1; i <= n; i++) {
        int a, b, s;
        cin >> a >> b >> s;
        int k = 1;
        while (k <= s) {
            cnt++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if (s > 0) {
            cnt++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }

    // 01 背包模板
    n = cnt;
    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= v[i]; j--) {
            f[j] = max(f[j], f[j-v[i]] + w[i]);
        }
    }

    // 输出答案
    cout << f[m] << endl;

}


