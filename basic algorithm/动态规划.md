# 动态规划

## 背包问题

略

## 区间 DP

### [282. 石子合并](https://www.acwing.com/problem/content/284/)

设有 N 堆石子排成一排，其编号为 1,2,3,…,N。

每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N 堆石子合并成为一堆。

每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

问题是：找出一种合理的方法，使总的代价最小，输出最小代价。

### 问题分析

目标是合并区间 `[i, j]`，但每次只能合并相邻的两堆石子，这意味着需要把 `[i, j]` 分成两大堆石子 `[i, k]` 和 `[K+1, j]`，最终的代价就是：分别合并两大堆石子 `[i, k]` 和 `[k+1, j]` 各自的代价，加上合并他们的总代价（也即，区间 `[i, j]` 的和）

### 递推公式

```C++
// 枚举 k from i to j-1
// f[i][j] 合并区间 [i, j] 的最小代价
// s[j] - s[i-1] 区间 [i, j] 的和
f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j] - s[i-1]);
```

### 代码

```C++
// 记搜
int n, a[N], s[N], f[N][N];
memset(f, -1, sizeof f);

int dfs(int i, int j) {
    if (f[i][j] != -1) return f[i][j];

    if (i == j) return f[i][j] = 0;
    // 枚举拆分成两个区间的位置
    // [i, j]->[i, k]和[k+1, j]
    int res = INF;
    for (int k = i; k < j; k++) {
        res = min(res, dfs(i, k) + dfs(k+1, j) + s[j] - s[i-1]);
    }
    return f[i][j] = res;
}
// 递推
// 先枚举区间长度
// 长度为 1 的区间 f[i][j] = 0
for (int len = 2; len <= n; len++) {
    // 枚举区间左端点
    for (int i = 1; i + len - 1 <= n; i++) {
        // 计算区间右端点
        int j = i + len - 1;
        // 枚举拆分区间的位置
        f[i][j] = 1e9;
        for (int k = i; k < j; k++) {
            f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j] - s[i-1]);
        }
    }
}
// 输出答案
cout << f[1][n] << endl;
```

## 计数类 DP

[900. 整数划分](https://www.acwing.com/problem/content/902/)

### 方法一：转化成完全背包问题

转化👍：一个容量是 n 的背包，物品的体积分别是 1~n，每种物品有无限个，问恰好装满背包的方案数是多少？

```C++
// 初始化
f[0] = 1;
// 枚举物品
for (int i = 1; i <= n; i++) {
    // 枚举体积
    // 完全背包 正向枚举就行
    for (int j = i; j <= n; j++) {
        // 计算方案数
        f[j] = ((LL)f[j] + f[j-i]) % MOD;
    }
}
cout << f[n] << endl;
```

### 方法二：

#### 状态表示

`f[i][j]` 表示所有总和是 i 并且恰好分成 j 个数的和的方案的数量

#### 状态计算

`f[i][j]` 划分成**最小值是 1** 和**最小值大于 1** 的两种情况

- 最小值是 1 的情况来自于：`f[i-1][j-1]`，也就是向总和是 i-1 并且恰好分成 j-1 个数的和的方案中加一个 1，便组成了 `f[i][j]`

- 最小值大于 1 的情况来自于：`f[i-j][j]`，也就是向总和是 i-j 并且恰好分成 j 个数的和的方案中的每一个数加 1，便得到了 `f[i][j]`

`f[i][j]` 只会来自于上述两种情况，得到递推公式：`f[i][j] = f[i-1][j-1] + f[i-j][j]` 

#### 答案

答案就是 1 ~ n 所有情况的求和：`ans = f[n][1] + f[n][2] + ... + f[n][n]`

```C++
f[0][0] = 1;
// 枚举和
for (int i = 1; i <= n; i++) {
    // 枚举个数
    for (int j = 1; j <= i; j++) {
        f[i][j] = (f[i-1][j-1] + f[i-j][j]) % MOD;
    }
}
int res = 0;
for (int i = 1; i <= n; i++) res = (res + f[n][i]) % MOD;
cout << res << endl;
```

## 数位统计 DP

### 问题原型

计算数字 a ~ b 中 1 出现的次数，数据范围 `1e8`。举例：1 ~ 12 中 1 出现的次数，包含 1 的数字：1、11、10、12，则 1 出现的次数是：5

### 分析

如果暴力求解的话，时间复杂度是：1e8 * 8，肯定超时

#### 分情况讨论

举例：`1 ~ n, i, n = abcdefg` 分别求出 i 在每一位上出现的次数

先求 i 在第 4 位上出现的次数，`1 <= xxxiyyy <= abcdefg`

1. 当 xxx = 000 ~ abc-1 时，yyy 的取值无约束：000 ~ 999，则有 abc * 1000 种选法

2. 当 xxx = abc 时，再分情况讨论：

    - 若 d < i，则 abc1yyy > abc0yyy，其中 d = 0，则方案数就是 0

    - 若 d = i，yyy = 000 ~ efg，则方案数是 1 + efg
    - 若 d > i，yyy 的取值无约束：000 ~ 999，则有 1000 种选法

上述两种情况的方案数加到一起就是 i 在第 4 位上出现的次数，其实也就是第 4 位上是 i 的数的个数。

时间复杂度：枚举 8 位 * 每一位最多 10 次运算

#### 边界问题：

- 当 i 出现在最高位时：情况 1 不存在，只算第二种情况
- 在枚举 i = 0 时，由于不能有前导零，前 3 位应该从 001 开始 

## 状态压缩DP

[AcWing 291. 蒙德里安的梦想](https://www.acwing.com/activity/content/problem/content/1010/)

### 思路分析

先放横着的方块，再放竖着的方块。横着的放完，竖着的直接插进去就行。所以，方案总数等于只放横着的小方块的合法方案数。

如何判断当前方案是否合法？所有剩余位置，能否填充满竖着的小方块。可以按列来看，每一列内部所有连续的空着的小方块，需要是偶数个

### 状态表示

`f[i][j]` 表示已经将前 `i-1` 列摆好，且从第 `i-1` 列，伸出到第 `i` 列的状态是 `j` 的所有方案

举例：

`*` 表示摆好了，`-` 表示未摆放，则下述状态是 `i = 2, j = 0b11001`
```C++
   0 1 2 3 4 5
0  * * * - - - 
1  * * * - - -
2  * * - - - -
3  * * - - - -
4  * * * - - -
```
解释：第 `i-1=1` 列已经全部摆满了，从第 `i-1=1` 列，伸出到第 `i=2` 列的状态是 `11001`

### 状态计算

假设 `f[i][j]` 由 `f[i-1][k]` 转移而来，则状态 `k` 和 `j` 之间必须满足以定的关系：

- 不重叠 `(k & j) == 0`
- 所有连续空着的位置的长度必须是偶数

答案就是 `f[m][0]` 表示前 `m` 列全部摆满，且伸出的状态是 `0`

#### 预处理

预处理有哪些状态 k 可以更新到 j

[91. 最短Hamilton路径](https://www.acwing.com/problem/content/93/)

> 又名，旅行商问题。一个 NP 完全问题：计算机没办法在多项式时间内求出问题的解

#### 核心思路

1. 哪些点被用过
2. 目前停在哪个点上

状态的数量：用过的点的状态 `2^20 * 20` 个点

### 状态表示

`f[state][j]` 表示，当前 state 下，停在了 j 点上

### 状态计算

`f[state][j] = f[state_k][k] + w[k][j]`，解释：`state_k + j = state`，也即，`state_k` 表示 `state` 除掉 `j` 这个点之后的集合，且 `state_k` 包含 `k`

时间复杂度：状态的数量 * 20 个点 = `2^20 * 20 * 20`，解释：所有状态的数量更新其余 20 个点

答案就是 `f[(1 << n) - 1][n-1]`，遍历所有的状态，且最终点在 n - 1 上

## 树形 DP

[285. 没有上司的舞会](https://www.acwing.com/problem/content/287/)

### 状态表示

`f[u][0]` 表示从所有以 u 为根的子树中选择，并且不选 u 这个点的方案数

`f[u][1]` 表示从所有以 u 为根的子树中选择，并且选 u 这个点的方案数

属性: `max`

### 状态计算

假设 u 的儿子：s1, s2, ..., si, ...

`f[u][0]` 应当是子树取最大

- `f[u][0] += max(f[si][0], f[si][1])`

`f[u][1]` 只能是不选儿子节点情况下取最大

- `f[u][1] += f[si][0]`

时间复杂度：O(n)









